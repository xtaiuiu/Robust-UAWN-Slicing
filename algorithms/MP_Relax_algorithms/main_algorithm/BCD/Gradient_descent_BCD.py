# find the local minima of the AL problem P_{\lambda, \rho} by projected gradient descent
import numpy as np

from utils.projction import proj_nonnegative_half_space_lb
import numpy.linalg as lg


def pgd_BCD(prob, lam, rho, x0, p0, eps=1e-8):
    """
    optimize sub_x by gradient projection method.
    Stepsize rule is generated by armijo rule
    :param prob: must be a BoundProblem object
    :param stepsize_rule: a callable
    :return: f_opt, x_opt
    """
    f_values = []
    alpha, gamma = 1.0, 0.5
    l = len(prob.a)
    f0 = 1e10
    z = np.concatenate((x0, p0))
    f = prob.Lagrangian_value(z[:l], z[l:], lam, rho)
    f_values.append(f)
    g = np.concatenate((prob.g_x(z[:l], z[l:], lam, rho), prob.g_p(z[:l], z[l:], lam, rho)))
    n, n_max = 0, 1000
    while abs((f0 - f) / f) > eps and n < n_max:
        print(f"n = {n}, f0 = {f0}, fx = {f}, norm_gx = {lg.norm(g)}, alpha = {alpha}")
        # eventually constant stepsize rule
        # while fx > f0 + np.dot(g0, x - x0) + lg.norm(x - x0)**2/(2*alpha):
        #     alpha *= gamma
        alpha = armijo_rule(prob, lam, rho, z, f, g)
        z0, f0 = z, f
        z = projection_for_BCD(prob.c, z0 - alpha * g, prob.B_tot, prob.x_u, prob.p_u)
        f = prob.Lagrangian_value(z[:l], z[l:], lam, rho)
        g = np.concatenate((prob.g_x(z[:l], z[l:], lam, rho), prob.g_p(z[:l], z[l:], lam, rho)))
        f_values.append(f)
        n += 1
    return f, z[:l], z[l:], np.array(f_values)


def armijo_rule(prob, lam, rho, z, f, g, beta=0.5, sigma=0.5):
    n = len(prob.a)
    s = 1.0
    m, m_max = 0, 100
    for m in range(m_max):
        z_k_alpha = projection_for_BCD(prob.c, z - beta ** m * s * g, prob.B_tot, prob.x_u, prob.p_u)
        #print(f"sigma: {sigma * np.dot(g, z - z_k_alpha)}")
        if f - prob.Lagrangian_value(z_k_alpha[:n], z_k_alpha[n:], lam, rho) >= sigma * np.dot(g, z - z_k_alpha):
            break
    return beta ** m * s


def projection_for_BCD(a, z, r, x_u, p_u):
    """
        Project z = (x, p) onto the feasible set of the AL problem
    a^T x <= r, x >= x_u, p >= p_u
    :param a: numpy array
    :param z: the point that will be projected
    :param r: a float
    :param x_u: numpy array represents lb of x
    :param p_u: numpy array represents lb of p
    :return: proj_x, proj_p
    """
    n = len(a)
    return np.concatenate((proj_nonnegative_half_space_lb(a, z[:n], r, x_u), np.maximum(z[n:], p_u)))
