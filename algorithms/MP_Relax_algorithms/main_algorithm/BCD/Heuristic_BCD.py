# solve the AL problem (i.e., P_{\lambda, \rho}) by using heuristic algorithms
import numpy as np
from mealpy import Problem, FloatVar


def violate_inequality(value):
    return 0 if value <= 0 else value


def violate_equality(value):
    return 0 if (value == 0 or abs(value) <= 1e-4) else abs(value)


class HeuProblemBCD(Problem):
    def __init__(self, prob, bounds, minmax, **kwargs):
        self.prob = prob
        self.n = len(prob.a)  # n is the number of UEs
        self.lam = kwargs.get('lam', 1.0)
        self.rho = kwargs.get('rho', 1.0)
        super().__init__(bounds, minmax, **kwargs)
        # for key, value in kwargs.items():
        #     if key == 'sc':
        #         self.sc = value
        #self.sc = sc  # sc is the network Scenario

    # constraints
    def cons_x(self, x):
        return self.prob.c @ x[:self.n] - self.prob.B_tot


    def obj_func(self, solution):
        p, n = self.prob, len(self.prob.a)
        x, y = solution[:n], solution[n:]
        fx = (np.sum(np.array([-p.a[i]*x[i]*np.log1p(p.b[i]*y[i]) for i in range(n)]))
              + self.lam * (x@y - p.P) + (x@y - p.P)**2/(2*self.rho))
        fx += violate_inequality(self.cons_x(solution)) * 1e6
        return fx


# calculate the upper bounds of the variables. the bounds are not tight. In fact, we cannot get
# a tight bound for each variable. These bounds are only used to confine the points generated by Heu
# algorithms.
# If no upper-bound is provided, Heu algorithms will produce very large points.
def prob_BCD_ub(prob):
    n = len(prob.a)
    if n == 1:
        return np.array([prob.B_tot / prob.c[0], prob.P / prob.x_u[0]])
    else:
        u_x, u_y = np.zeros(n), np.zeros(n)
        for i in range(n):
            mask = np.ones(n, dtype=bool)
            mask[i] = False
            u_x[i] = (prob.B_tot - np.dot(prob.c[mask], prob.x_u[mask])) / prob.c[i]
            u_y[i] = (prob.P - np.dot(prob.p_u[mask], prob.x_u[mask])) / prob.x_u[i]
        return np.concatenate((u_x, u_y))


def BCD_by_heuristic(prob, lam, rho, heu_model):
    """
    :param prob: OptimizationProblem object
    :param heu_model: the heuristic model, which is created like:
    model_pso = PSO.OriginalPSO(epoch=1000, pop_size=100)
    :return: f_val, var
    """
    # f, x, y = penalty_bcd_alg(prob)
    # print(f"f_pdd = {f}, x = {x}, y = {y}")
    lb = np.concatenate((prob.x_u, prob.p_u))
    ub = np.concatenate((np.ones_like(prob.x_u) * prob.B_tot, np.ones_like(prob.p_u) * prob.P))
    #ub = np.concatenate((x, y)) * 1.5
    problem_cop = HeuProblemBCD(prob, FloatVar(lb=lb, ub=prob_BCD_ub(prob)), minmax="min", lam=lam, rho=rho)
    heu_model.solve(problem=problem_cop)

    return -heu_model.g_best.target.fitness, heu_model.g_best.solution