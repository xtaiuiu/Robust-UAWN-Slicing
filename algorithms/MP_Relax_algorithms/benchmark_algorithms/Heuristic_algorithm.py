# generate problem instance
# and solve the original problem by heuristics

import logging
import time

import numpy as np
from matplotlib import pyplot as plt
from mealpy import PSO, FloatVar
from mealpy.math_based import SHIO
from mealpy.utils.problem import Problem
from pathlib import Path

from algorithms.MP_Relax_algorithms.main_algorithm.DAL.DAL_algorithm import DAL_alg, optimize_x_cvx, \
    optimize_p_BFGS
from scenarios.scenario_creators import create_scenario, scenario_to_problem
from algorithms.MP_Relax_algorithms.main_algorithm.Sub_xp.GPM_algorithm import gpm_x


def violate_inequality(value):
    return 0 if value <= 0 else value


def violate_equality(value):
    return 0 if (value == 0 or abs(value) <= 1e-4) else abs(value)


class HeuProblem(Problem):
    def __init__(self, prob, bounds, minmax, **kwargs):
        self.prob = prob
        self.n = len(prob.a)  # n is the number of UEs
        super().__init__(bounds, minmax, **kwargs)
        # for key, value in kwargs.items():
        #     if key == 'sc':
        #         self.sc = value
        #self.sc = sc  # sc is the network Scenario

    # constraints
    def cons_x(self, x):
        return self.prob.c @ x[:self.n] - self.prob.B_tot

    def cons_xp(self, x):
        return x[:self.n] @ x[self.n:] - self.prob.P

    def obj_func(self, solution):
        p, n = self.prob, len(self.prob.a)
        x, y = solution[:n], solution[n:]
        fx = np.sum(np.array([-p.a[i]*x[i]*np.log1p(p.b[i]*y[i]) for i in range(n)]))
        fx += violate_inequality(self.cons_x(solution)) * 1e6 + violate_inequality(self.cons_xp(solution)) * 1e6
        return fx


# calculate the upper bounds of the variables. the bounds are not tight. In fact, we cannot get
# a tight bound for each variable. These bounds are only used to confine the points generated by Heu
# algorithms.
# If no upper-bound is provided, Heu algorithms will produce very large points.
def prob_up(prob):
    n = len(prob.a)
    if n == 1:
        return np.array([prob.B_tot / prob.c[0], prob.P / prob.x_u[0]])
    else:
        u_x, u_y = np.zeros(n), np.zeros(n)
        for i in range(n):
            mask = np.ones(n, dtype=bool)
            mask[i] = False
            u_x[i] = (prob.B_tot - np.dot(prob.c[mask], prob.x_u[mask])) / prob.c[i]
            u_y[i] = (prob.P - np.dot(prob.p_u[mask], prob.x_u[mask])) / prob.x_u[i]
        return np.concatenate((u_x, u_y))


def optimize_by_heuristic(prob, heu_model):
    """
    :param prob: OptimizationProblem object
    :param heu_model: the heuristic model, which is created like:
    model_pso = PSO.OriginalPSO(epoch=1000, pop_size=100)
    :return: f_val, var
    """
    # f, x, y = penalty_bcd_alg(prob)
    # print(f"f_pdd = {f}, x = {x}, y = {y}")
    lb = np.concatenate((prob.x_u, prob.p_u))
    ub = np.concatenate((np.ones_like(prob.x_u) * prob.B_tot, np.ones_like(prob.p_u) * prob.P))
    #ub = np.concatenate((x, y)) * 1.5
    problem_cop = HeuProblem(prob, FloatVar(lb=lb, ub=prob_up(prob)), minmax="min")
    heu_model.solve(problem=problem_cop)

    return heu_model.g_best.target.fitness, heu_model.g_best.solution


if __name__ == '__main__':
    #logging.basicConfig(level=logging.WARNING)
    #logging.disable(logging.INFO)
    f_HEU, f_WARM, f_RAND = [], [], []
    sc = create_scenario(100, 500)
    n_repeats = 10
    for i in range(n_repeats):

        #np.random.seed(0)
        #prob = create_optimization_instance(n=np.random.randint(20, 201))
        #sc = create_scenario(2, 500)
        # 获取当前脚本所在的目录
        current_dir = Path(__file__).resolve().parent
        # 构建目标文件的路径
        target_file_path = current_dir.parent.parent / 'scenarios' / 'sc_2_slices.pickle'
        sc.pn.p_max = 300000 + i*100000
        prob = scenario_to_problem(sc)
        l = len(prob.a)

        model_learn = PSO.AIW_PSO(epoch=500, pop_size=50)
        model_shio = SHIO.OriginalSHIO(epoch=500, pop_size=50)
        #model_shio = PSO.P_PSO(epoch=1000, pop_size=200)
        t1 = time.perf_counter()
        f_shio, x_shio = optimize_by_heuristic(prob, model_shio)
        t2 = time.perf_counter()
        f_warm, x_warm, p_warm, _, _, _ = DAL_alg(prob, x_shio[:l], x_shio[l:], subx_optimizer=optimize_x_cvx, subp_optimizer=optimize_p_BFGS)
        t3 = time.perf_counter()
        f_rand, x_rand, p_rand, _, _, _ = DAL_alg(prob, prob.x_u, prob.p_u, subx_optimizer=optimize_x_cvx, subp_optimizer=optimize_p_BFGS)

        print("______________________check feasibility of shio solution______________________________")
        # check feasibility of shio solution
        print(f"c^T x - B_tot = {prob.c @ x_shio[:l] - prob.B_tot}")
        print(f"x^p - P = {x_shio[:l] @ x_shio[l:] - prob.P}")
        print(f"min(x - prob.x_u) = {np.min(x_shio[:l] - prob.x_u)}")
        print(f"min(p - prob.p_u) = {np.min(x_shio[l:] - prob.p_u)}")
        print(f"f_heu = {f_shio}, f_compute_heu = {prob.objective_function(x_shio[:l], x_shio[l:])}")


        print("_________________________check feasibility of DAL rand solution___________________________")

        # check feasibility of DAL rand solution
        print(f"c^T x - B_tot = {prob.c @ x_rand - prob.B_tot}")
        print(f"x^p - P = {x_rand @ p_rand - prob.P}")
        print(f"min(x - prob.x_u) = {np.min(x_rand - prob.x_u)}")
        print(f"min(p - prob.p_u) = {np.min(p_rand - prob.p_u)}")

        print("__________________________check feasibility of DAL warm solution______________________________")

        # check feasibility of DAL warm solution
        print(f"c^T x - B_tot = {prob.c @ x_warm - prob.B_tot}")
        print(f"x^p - P = {x_warm @ p_warm - prob.P}")
        print(f"min(x - prob.x_u) = {np.min(x_warm - prob.x_u)}")
        print(f"min(p - prob.p_u) = {np.min(p_warm - prob.p_u)}")

        print(f"f_shio = {f_shio}, f_rand = {-f_rand}, f_warm = {-f_warm}")
        print(f"original f_val: f_shio = {prob.objective_function(x_shio[:l], x_shio[l:])}, "
              f"f_rand = {prob.objective_function(x_rand, p_rand)}, "
              f"f_warm = {prob.objective_function(x_warm, p_warm)}")

        print(f"total time = {t3 - t1}, mealpy time = {t2 - t1}, DAL time = {t3 - t2}")

        f_HEU.append(-prob.objective_function(x_shio[:l], x_shio[l:]))
        f_WARM.append(-prob.objective_function(x_warm, p_warm))
        f_RAND.append(-prob.objective_function(x_rand, p_rand))
    plt.plot(np.array(f_HEU), 'b-o', label='heu')
    plt.plot(np.array(f_WARM), 'c:*', label='warm')
    plt.plot(np.array(f_RAND), 'r-.s', label='rand')
    plt.legend()
    plt.show()
